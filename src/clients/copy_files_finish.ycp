/**
 * File:
 *  copy_files_finish.ycp
 *
 * Module:
 *  Step of base installation finish
 *
 * Authors:
 *  Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 */

{

textdomain "installation";

import "AddOnProduct";
import "Linuxrc";
import "Installation";
import "Directory";
import "ProductControl";
import "FileUtils";
import "String";

include "installation/misc.ycp";

any ret = nil;
string func = "";
map param = $[];

/* Check arguments */
if(size(WFM::Args()) > 0 && is(WFM::Args(0), string)) {
    func = (string)WFM::Args(0);
    if(size(WFM::Args()) > 1 && is(WFM::Args(1), map))
	param = (map)WFM::Args(1);
}

y2milestone ("starting copy_files_finish");
y2debug("func=%1", func);
y2debug("param=%1", param);

if (func == "Info")
{
    return (any)$[
	"steps" : 1,
	// progress step title
	"title" : _("Copying files to installed system..."),
	"when" : [ `installation, `update, `autoinst ],
    ];
}
else if (func == "Write")
{
    // bugzilla #221815
    // Adding blacklisted modules into the /etc/modprobe.d/blacklist
    // This should run before the SCR::switch function
    AdjustModprobeBlacklist();

    // copy hardware status to installed system
    SCR::Execute (.target.bash,"/bin/cp -a '/var/lib/hardware' " +
	"'" + String::Quote (Installation::destdir) + "/var/lib'");

    // if VNC, copy setup data
    if (Linuxrc::vnc ())
    {
	WFM::Execute (.local.bash, "/bin/cp -a '/root/.vnc' " +
	    "'" + String::Quote (Installation::destdir) + "/root'");
    }


    // --------------------------------------------------------------
    // Copy /etc/install.inf into built system so that the
    // second phase of the installation can find it.
    Linuxrc::SaveInstallInf (Installation::destdir);

    // Copy control.xml so it can be read once again during continue mode
    SCR::Execute (.target.bash, "/bin/cp " + ProductControl::current_control_file  + " " +
	"'" + String::Quote (Installation::destdir) + Directory::etcdir + "/control.xml'");
    SCR::Execute (.target.bash, "/bin/chmod 0644 " +
	"'" + String::Quote (Installation::destdir) + Directory::etcdir + "/control.xml'");

    // Copy also control files of add-on products
    string cf_dir = (string)SCR::Read (.target.tmpdir) + "/control_files";
    string system_cf_dir = Installation::destdir + Directory::etcdir + "/control_files";

    // BNC #471929
    // Removing previously used control files (and order.ycp)
    y2milestone (
	"Removing %1 -> %2",
	system_cf_dir,
	SCR::Execute (.target.bash, sformat ("rm -rf '%1'", String::Quote (system_cf_dir)))
    );

    if (size (AddOnProduct::control_files_to_add) > 0)
    {
	SCR::Execute (.target.bash, "/bin/mkdir -p '" + String::Quote (system_cf_dir) + "'");

	foreach (string file, AddOnProduct::control_files_to_add, {
	    SCR::Execute (.target.bash, "/bin/cp " + cf_dir + "/" + file + " " +
		"'" + String::Quote (system_cf_dir) + "'");
	    SCR::Execute (.target.bash, "/bin/chmod 0644 " +
		"'" + String::Quote (system_cf_dir) + file + "'");
	});

	SCR::Write (.target.ycp, system_cf_dir + "/order.ycp", AddOnProduct::control_files_to_add);

	SCR::Execute (.target.bash, "/bin/chmod 0644 " + "'" + String::Quote (system_cf_dir) + "/order.ycp'");
    }

    // Remove old eula.txt
    // bugzilla #208908
    string eula_txt = sformat ("%1%2/eula.txt", Installation::destdir, Directory::etcdir);
    if (FileUtils::Exists (eula_txt)) {
	SCR::Execute (.target.remove, eula_txt);
    }

    // Copy info.txt so it can be used in firstboot (new eula.txt)
    if (FileUtils::Exists ("/info.txt"))
    {
	SCR::Execute (.target.bash, sformat("/bin/cp /info.txt %1", eula_txt));
    }
}
else
{
    y2error ("unknown function: %1", func);
    ret = nil;
}

y2debug("ret=%1", ret);
y2milestone("copy_files_finish finished");
return ret;


} /* EOF */
